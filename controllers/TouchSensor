import time
import threading
import random
from typing import Optional, Callable, Dict, List, Any, copy


class ExperimentTimer:
    """
    Experiment Timer Module (Supervisors - God View)
    Core functionality:
    - Control experiment duration
    - Start/stop/pause timing
    - Calculate remaining time
    - Trigger timeout callbacks
    """
    def __init__(self, total_duration: int = 3600):
        """
        Initialize experiment timer
        :param total_duration: Total experiment duration in seconds (default: 1 hour)
        """
        self.total_duration = total_duration  # Total experiment time
        self.remaining_time = total_duration  # Remaining time
        self.is_running = False               # Timer state
        self.is_paused = False                # Pause state
        self.start_timestamp: Optional[float] = None  # Start time stamp
        self.timer_thread: Optional[threading.Thread] = None  # Timer thread
        self.timeout_callback: Optional[Callable] = None  # Timeout callback function
        self._lock = threading.Lock()  # Thread safety lock

    def start(self) -> None:
        """Start the experiment timer"""
        with self._lock:
            if self.is_running or self.is_paused:
                return

            self.is_running = True
            self.is_paused = False
            self.start_timestamp = time.time()
            self.timer_thread = threading.Thread(target=self._timer_loop, daemon=True)
            self.timer_thread.start()
            print(f"[Timer] Started - Total duration: {self.total_duration}s")

    def pause(self) -> None:
        """Pause the experiment timer"""
        with self._lock:
            if not self.is_running or self.is_paused:
                return

            self.is_paused = True
            self.is_running = False
            # Calculate elapsed time before pause
            if self.start_timestamp:
                elapsed = time.time() - self.start_timestamp
                self.remaining_time = max(0, self.remaining_time - elapsed)
            print(f"[Timer] Paused - Remaining time: {self.get_remaining_time()['formatted']}")

    def resume(self) -> None:
        """Resume the paused experiment timer"""
        with self._lock:
            if self.is_running or not self.is_paused:
                return

            self.is_paused = False
            self.is_running = True
            self.start_timestamp = time.time()
            self.timer_thread = threading.Thread(target=self._timer_loop, daemon=True)
            self.timer_thread.start()
            print(f"[Timer] Resumed - Remaining time: {self.get_remaining_time()['formatted']}")

    def stop(self) -> None:
        """Stop the experiment timer (reset state)"""
        with self._lock:
            self.is_running = False
            self.is_paused = False
            self.remaining_time = self.total_duration
            self.start_timestamp = None
            print("[Timer] Stopped and reset")

    def set_timeout_callback(self, callback: Callable) -> None:
        """Set callback function for timeout event"""
        self.timeout_callback = callback

    def _timer_loop(self) -> None:
        """Internal timer loop (runs in background thread)"""
        while True:
            with self._lock:
                if not self.is_running or self.remaining_time <= 0:
                    break

                # Calculate remaining time
                if self.start_timestamp:
                    elapsed = time.time() - self.start_timestamp
                    self.remaining_time = max(0, self.total_duration - elapsed)

            time.sleep(1)  # Update every 1 second

        # Trigger timeout callback if needed
        with self._lock:
            if self.remaining_time <= 0 and self.timeout_callback:
                print("[Timer] Timeout condition met")
                self.timeout_callback()
            self.is_running = False

    def get_remaining_time(self) -> Dict[str, Any]:
        """Get formatted remaining time (seconds/minutes/hours)"""
        with self._lock:
            remaining = self.remaining_time
            hours = int(remaining // 3600)
            minutes = int((remaining % 3600) // 60)
            seconds = int(remaining % 60)

            return {
                "total_seconds": remaining,
                "formatted": f"{hours:02d}:{minutes:02d}:{seconds:02d}",
                "hours": hours,
                "minutes": minutes,
                "seconds": seconds
            }


class TouchSensorListener:
    """
    Touch Sensor Listener Module (Supervisors - God View)
    Core functionality:
    - Monitor touch sensor events
    - Collect sensor data
    - Trigger update callbacks for Score & Logging module
    """
    def __init__(self, sensor_ids: List[str]):
        """
        Initialize touch sensor listener
        :param sensor_ids: List of touch sensor unique identifiers
        """
        self.sensor_ids = sensor_ids  # Registered sensor IDs
        self.sensor_states: Dict[str, bool] = {sid: False for sid in sensor_ids}  # Sensor touch states
        self.is_monitoring = False  # Monitoring state
        self.monitor_thread: Optional[threading.Thread] = None  # Monitoring thread
        self.update_callback: Optional[Callable[[Dict[str, Any]], None]] = None  # Update callback
        self._lock = threading.Lock()  # Thread safety lock
        self._sampling_interval = 0.1  # 100ms sampling rate (configurable)

    def set_sampling_interval(self, interval: float) -> None:
        """Set sensor sampling interval (in seconds)"""
        with self._lock:
            if interval > 0:
                self._sampling_interval = interval
                print(f"[Sensor] Sampling interval set to {interval}s")

    def start_monitoring(self) -> None:
        """Start monitoring touch sensor events"""
        with self._lock:
            if self.is_monitoring:
                return

            self.is_monitoring = True
            self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
            self.monitor_thread.start()
            print(f"[Sensor] Started monitoring {len(self.sensor_ids)} sensors")

    def stop_monitoring(self) -> None:
        """Stop monitoring touch sensor events"""
        with self._lock:
            self.is_monitoring = False

        # Wait for thread to exit (optional, for clean shutdown)
        if self.monitor_thread and self.monitor_thread.is_alive():
            self.monitor_thread.join(timeout=1.0)
        print("[Sensor] Stopped monitoring")

    def set_update_callback(self, callback: Callable[[Dict[str, Any]], None]) -> None:
        """Set callback for sensor state updates (for Score & Logging module)"""
        self.update_callback = callback

    def _read_sensor_state(self, sensor_id: str) -> bool:
        """
        Simulate reading physical touch sensor state
        Replace with actual hardware communication logic in production
        :param sensor_id: Target sensor ID
        :return: True if touched, False otherwise
        """
        # --------------------------
        # TODO: Replace with real hardware API calls
        # Example for Raspberry Pi GPIO:
        # import RPi.GPIO as GPIO
        # return GPIO.input(sensor_pin_map[sensor_id])
        # --------------------------
        # Simulate: 20% chance of touch (more realistic than 50/50)
        return random.random() < 0.2

    def _monitor_loop(self) -> None:
        """Internal monitoring loop (runs in background thread)"""
        while True:
            # Check if monitoring should stop
            with self._lock:
                if not self.is_monitoring:
                    break
                interval = self._sampling_interval

            # Collect state for all registered sensors
            sensor_data = {
                "timestamp": time.time(),
                "timestamp_str": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                "sensor_states": {},
                "touched_sensors": [],
                "sampling_interval": interval
            }

            # Read sensor states (thread-safe)
            with self._lock:
                for sid in self.sensor_ids:
                    state = self._read_sensor_state(sid)
                    self.sensor_states[sid] = state
                    sensor_data["sensor_states"][sid] = state
                    if state:
                        sensor_data["touched_sensors"].append(sid)

            # Trigger update callback (only if state changed to reduce noise)
            if self.update_callback and sensor_data["touched_sensors"]:
                self.update_callback(sensor_data)

            # Sleep with interval (thread-safe)
            time.sleep(interval)

    def get_current_sensor_states(self) -> Dict[str, bool]:
        """Get current state of all touch sensors (thread-safe copy)"""
        with self._lock:
            return copy.deepcopy(self.sensor_states)


# ------------------------------
# Callback Functions (Business Logic)
# ------------------------------
def handle_experiment_timeout() -> None:
    """Callback for experiment timeout"""
    print("\n=== [Experiment] Timeout! Experiment completed ===")


def handle_sensor_update(sensor_data: Dict[str, Any]) -> None:
    """Callback for sensor updates (Score & Logging integration)"""
    touched = sensor_data["touched_sensors"]
    if touched:
        print(f"[Sensor Update] {sensor_data['timestamp_str']} - Touched sensors: {touched}")


# ------------------------------
# Example Usage (Integration Demo)
# ------------------------------
if __name__ == "__main__":
    # 1. Initialize Experiment Timer (30-second test duration)
    experiment_timer = ExperimentTimer(total_duration=30)
    experiment_timer.set_timeout_callback(handle_experiment_timeout)

    # 2. Initialize Touch Sensor Listener (3 sensors)
    sensor_ids = ["TS001", "TS002", "TS003"]
    touch_sensor_listener = TouchSensorListener(sensor_ids=sensor_ids)
    touch_sensor_listener.set_sampling_interval(0.2)  # 200ms sampling rate
    touch_sensor_listener.set_update_callback(handle_sensor_update)

    # 3. Start modules
    print("\n=== Starting Experiment Supervision ===")
    experiment_timer.start()
    touch_sensor_listener.start_monitoring()

    # 4. Simulate experiment workflow
    try:
        # Run for 10 seconds
        print("\n=== Running experiment (10s) ===")
        time.sleep(10)

        # Pause timer for 2 seconds
        print("\n=== Pausing experiment (2s) ===")
        experiment_timer.pause()
        time.sleep(2)

        # Resume timer
        print("\n=== Resuming experiment ===")
        experiment_timer.resume()
        
        # Run until timeout (20 seconds)
        print("=== Running until timeout (20s) ===")
        time.sleep(20)

    except KeyboardInterrupt:
        print("\n=== Experiment interrupted by user ===")
    finally:
        # 5. Cleanup
        experiment_timer.stop()
        touch_sensor_listener.stop_monitoring()
        print("\n=== Experiment Supervision Ended ===")
